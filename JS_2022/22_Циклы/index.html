<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../style.css">
  <title>Циклы</title>
</head>

<body>
  <a href="../../index.html">
    <div class="home">в начало</div>
  </a>

  <div class="container">
    <h3>Циклы</h3>

    <img src="Условия_циклы.jpg" alt="условия_циклы">
    <p>При написании скриптов зачастую встаёт задача сделать однотипное действие много раз. <br>
      Для многократного повторения одного участка кода предусмотрены циклы</p>

    <h3>Цикл «while»</h3>
    <p>Цикл <span>while</span> имеет следующий синтаксис: </p>
    <pre><code>while (condition) {
    // код
    // также называемый "телом цикла"
}</code></pre>
    <p>Код из тела цикла выполняется, пока условие condition истинно. <br>
      Например, цикл ниже выводит <span>i</span> , пока <span>i < 3</span>:</p>
    <pre><code>let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}</code></pre>

    <p>Одно выполнение тела цикла по-научному называется итерация. Цикл в примере выше совершает три итерации.</p>
    <h3>Цикл «do…while»</h3>
    <p>Проверку условия можно разместить под телом цикла, используя специальный синтаксис <span>do..while</span>:
    </p>
    <pre><code>do {
// тело цикла
} while (condition);</code></pre>

    <p>Цикл сначала выполнит тело, а затем проверит условие <span>condition</span>, и пока его значение равно
      <span>true</span>, он будет
      выполняться снова и снова. <br>
      Например:
    </p>
    <pre><code>let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);</code></pre>
    <p>Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если
      условие окажется ложным. На практике чаще используется форма с предусловием: <span>while(…) {…}</span>.</p>

    <h3>Цикл «for»</h3>
    <p>Еще одна форма цикла, выгдит она вот так:</p>
    <pre><code>for (начало; условие; шаг) {
  // ... тело цикла ...
}</code></pre>
    <p>Например:</p>
    <pre><code>for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}</code></pre>
    <p>В примере переменная счётчика <span>i</span> была объявлена прямо в цикле. Это так называемое «встроенное»
      объявление
      переменной. Такие переменные существуют только внутри цикла.</p>


    <h3>Прерывание цикла: «break»</h3>
    <p>Обычно цикл завершается при вычислении условия в <span>false</span>. <br>
      Но мы можем выйти из цикла в любой момент с помощью специальной директивы <span>break</span>.<br>
      Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем –
      выдаёт:</p>
    <pre><code>let sum = 0;

while (true) {
  let value = +prompt("Введите число", '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Сумма: ' + sum );</code></pre>
    <p>Директива <span>break</span> в строке <span>(*)</span> полностью прекращает выполнение цикла и передаёт
      управление на
      строку за его телом, то есть на <span>alert</span>.</p>

    <h3>Переход к следующей итерации: continue</h3>
    <p>Директива <span>continue</span> – «облегчённая версия» <span>break</span>. При её выполнении цикл не
      прерывается, а переходит к
      следующей итерации (если условие все ещё равно true). <br>
      Её используют, если понятно, что на текущем повторе цикла делать больше нечего. <br>
      Например, цикл ниже использует <span>continue</span>, чтобы выводить только нечётные значения:</p>
    <pre><code>for (let i = 0; i < 10; i++) {

  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;

  alert(i); // 1, затем 3, 5, 7, 9
}
</code></pre>
    <p>Для чётных значений <span>i</span>, директива <span>continue</span> прекращает выполнение тела цикла и
      передаёт управление на следующую
      итерацию <span>for</span> (со следующим числом). Таким образом <span>alert</span> вызывается только для
      нечётных значений.</p>

    <h3>Метки для break/continue</h3>
    <p>Бывает, нужно выйти одновременно из нескольких уровней цикла сразу. <br>
      Например, в коде ниже мы проходимся циклами <span>i</span> по и <span>j</span>, запрашивая с помощью
      <span>prompt</span>
      координаты <span>(i, j)</span> с <span>(0,0)</span> до <span>(2,2)</span>:
    </p>
    <pre><code>for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {
    let input = prompt(`Значение на координатах (${i},${j})`, '');
    // Что если мы захотим перейти к Готово (ниже) прямо отсюда?
  }
}

alert('Готово!');</code></pre>
    <p>Нам нужен способ остановить выполнение, если пользователь отменит ввод. <br>
      Обычный <span>break</span> после <span>input</span> лишь прервёт внутренний цикл, но этого недостаточно.
      Достичь желаемого поведения
      можно с помощью меток. <br>
      Метка имеет вид идентификатора с двоеточием перед циклом:</p>
    <pre><code>labelName: for (...) {
  ...
}</code></pre>

    <p>Вызов <span>break &ltlabelName&gt</span>в цикле ниже ищет ближайший внешний цикл с такой меткой и
      переходит в
      его конец.</p>
    <pre><code>outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}
alert('Готово!');</code></pre>
    <p>В примере выше это означает, что вызовом <span>break outer</span> будет разорван внешний цикл до метки с
      именем <span>outer</span>. </p>
    <p>Таким образом управление перейдёт со строки, помеченной <span>(*)</span> , к <span>alert('Готово!')</span>.
    </p>

    <h3>Итого:</h3>
    <ul>
      <li>
        <span>while</span> – Проверяет условие перед каждой итерацией.
      </li>
      <li><span>do..while</span> – Проверяет условие после каждой итерации.</li>
      <li><span>for (;;)</span> – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные
        настройки.</li>
    </ul>

    <!-- Задачи: -->
    <details>
      <summary>
        Дополнительные задачки:
      </summary>
      <p><a
          href="https://github.com/yankovalenko94/JS_task_answers/blob/master/Tests/1_cycles_and_conditions/basic_cycles_cond.js">Решение
          1-5</a>
      </p>
      <p><a
          href="https://github.com/yankovalenko94/JS_task_answers/blob/master/Tests/1_cycles_and_conditions/cycles_and_cond_2.js">Решение
          5-8</a>
      </p>
      <ol>
        <li>
          <p>При помощи цикла выведите числа от 5 до 10 в консоль. 5 и 10 включительно. Цикл можно использовать любой
          </p>
          <pre><code>function firstTask() {
    // Пишем решение вот тут
}
firstTask()</code></pre>
        </li>
        <li>
          <p>При помощи цикла <span>for</span> вывести числа от 20 до 10 в консоль. В <span>обратном</span> порядке (20,
            19, 18...).
            Когда цикл
            дойдет до числа 13 - остановить весь цикл</p>
          <pre><code>function secondTask() {
    // Пишем решение вот тут
}
secondTask()</code></pre>
        </li>
        <li>
          <p>При помощи цикла <span>for</span> выведите чётные числа от 2 до 10 включительно</p>
          <pre><code>function thirdTask() {
    // Пишем решение вот тут
}
thirdTask()</code></pre>
        </li>
        <li>
          <p>Перепишите цикл <span>for</span> на вариант с <span>while</span> . Результат должен остаться точно таким
            же. Не создайте бесконечный
            цикл! Иначе браузер может зависнуть.</p>
          <pre><code>Цикл, который нужно переписать:

for (let i = 2; i <= 16; i++) {
    if (i % 2 === 0) {
        continue;
    } else {
        console.log(i);
    }
}</code></pre>
        </li>
        <li>
          <p>Заполните массив цифрами от 5 до 10 включительно. Помните, что элементы массива можно сформировать так же,
            как и обращаться к ним: <span>arr[0]</span></p>
          <pre><code>function fifthTask() {
    const arrayOfNumbers = [];
    // Пишем решение вот тут
    
    // Не трогаем
    return arrayOfNumbers;
}</code></pre>
        </li>
        <li>
          <p>Заполните новый массив (result) числами из старого (arr). Количество элементов в массиве можно получить как
            arr.length, а к элементам обращаемся все так же: arr[0], arr[1] и тд.
            Должен получиться точно такой же массив</p>
        </li>
        <pre><code>function firstTask() {
    // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
    const arr = [3, 5, 8, 16, 20, 23, 50];
    const result = [];
    // Пишем решение вот тут

    // Не трогаем
    return result;
}</code></pre>

        <li>
          <p>
            Измените данный массив так, чтобы все числа были увеличены в 2 раза, а если попадается строка строка - то к
            ней было добавлено " - done".
            Для определения типа данных используйте typeof();
            Должно получиться: <span>[ 10, 20, 'Shopping - done', 40, 'Homework - done' ]</span>
          </p>
          <pre><code>function secondTask() {
// Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
const data = [5, 10, 'Shopping', 20, 'Homework'];
// Пишем решение вот тут

// Не трогаем
return data;
}</code></pre>
        </li>

        <li>
          <p>
            Разверните массив data наоборот при помощи цикла и запишите данные в массив result.
            Должно получиться: <span>[ 'Homework', 20, 'Shopping', 10, 5 ]</span>
          </p>
          <pre><code>function thirdTask() {
// Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
const data = [5, 10, 'Shopping', 20, 'Homework'];
const result = [];

// Пишем решение вот тут</code></pre>
        </li>
      </ol>

    </details>

    <h3>Полезные ссылки</h3>
    <ul>
      <li><a href="https://learn.javascript.ru/while-for">Циклы learn js</a></li>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/label">Документация по
          меткам</a></li>
    </ul>
  </div>
  <script src="script.js"></script>
</body>

</html>